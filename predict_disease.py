# -*- coding: utf-8 -*-
"""Predict_Disease.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PNgRaDUDJ5XalHIxbevt4zshN1R7QRis
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import warnings
warnings.filterwarnings('ignore')

#Reading the train_csv by removing the last column since it's an empty column
data = pd.read_csv('Training.csv').dropna(axis=1)

data.head()

data.info()

data.shape

data.describe().T

data.isnull().sum().sum()

#Checking whether the dataset is balanced or not
disease_counts = data['prognosis'].value_counts()
temp_data = pd.DataFrame({
    'Disease':disease_counts.index,
    'Counts':disease_counts.values
})
plt.figure(figsize=(18, 8))
sns.barplot(x = 'Disease', y = 'Counts', data = temp_data)
plt.xticks(rotation=90)
plt.show()

#Encoding the target value into numerical
#value using LabelEncoder
encoder = LabelEncoder()
data['prognosis'] = encoder.fit_transform(data['prognosis'])
data

X = data.drop('prognosis',axis=1)
y = data['prognosis']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
print(f"Train:{X_train.shape},{y_train.shape}")
print(f"Test:{X_test.shape},{y_test.shape}")

"""**We choose Decision tree classifier model**"""

from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, export_text
from sklearn.metrics import accuracy_score

# Initialize and train the Decision Tree model
model = DecisionTreeClassifier(random_state=42)
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f"Model Accuracy: {accuracy*100:.2f}")

"""**then we choose Random Forest Classifier to avoid over fittinng**"""

#Training and Testing Random Forest Classifier
rf_model = RandomForestClassifier()
rf_model.fit(X_train, y_train)
preds = rf_model.predict(X_test)
print(f"Accuracy on train data by Random Forest Classifier: {accuracy_score(y_train, rf_model.predict(X_train))*100}")
print(f"Accuracy on test data by Random Forest Classifier: {accuracy_score(y_test, preds)*100}")
print()
cf_matrix = confusion_matrix(y_test, preds)
plt.figure(figsize=(12, 8))
sns.heatmap(cf_matrix, annot=True, cmap="YlOrRd")
plt.title("Confusion Matrix for Random Forest Classifier on Test Data")
plt.show()
print(classification_report(y_test, preds))
joblib.dump(rf_model, 'rf_model.pkl')
joblib.dump(encoder, 'label_encoder.pkl')



import pandas as pd
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from ipywidgets import VBox, Checkbox, Button, Output
from IPython.display import display

# Widgets setup
symptoms = X.columns
checkboxes = [Checkbox(value=False, description=symptom) for symptom in symptoms]
result_output = Output()

# Predict function
def predict_disease(button):
    # Collect user input
    user_data = [1 if checkbox.value else 0 for checkbox in checkboxes]
    user_df = pd.DataFrame([user_data], columns=symptoms)

    # Load model and label encoder
    model = joblib.load('rf_model.pkl')
    label_enc = joblib.load('label_encoder.pkl')

    # Make prediction
    prediction = model.predict(user_df)[0]
    predicted_disease = label_enc.inverse_transform([prediction])[0]

    # Display result
    with result_output:
        result_output.clear_output()
        print(f"The predicted disease is: {predicted_disease}")

# Button setup
predict_button = Button(description="Predict Disease")
predict_button.on_click(predict_disease)

# Layout
ui = VBox([
    VBox(checkboxes),  # Arrange checkboxes vertically
    predict_button,
    result_output
])

# Display UI
display(ui)



